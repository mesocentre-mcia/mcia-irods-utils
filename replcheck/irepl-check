#! /usr/bin/env python

from icommand import IrodsCommand, isrel, guess_icwd, guess_user

def iquest_replicas(path, user = None, recursive = False, resource_group = None):
    "gather replica status dictionary"

    def iquest_filter(e):
        if "CAT_NO_ROWS_FOUND" in e: return {}
        ret = {}

        for l in e.split():
            path, replnum = l.split(':')
            if path not in ret: ret[path] = 0
            ret[path] += int(replnum)

        return ret

    iquest = IrodsCommand("iquest", ["--no-page", "no-distinct", "%s/%s:%s"],
                          output_filter = iquest_filter, verbose = False)

    condition1_list = ["COLL_NAME = '%s'" % path]
    condition2_list = ["COLL_NAME like '%s/%%'" % path]

    if user:
        user_condition = "DATA_OWNER_NAME = '%s'" % user
        condition1_list.append(user_condition)
        condition2_list.append(user_condition)

    if resource_group:
        rg_condition = "RESC_GROUP_NAME = '%s'" % resource_group
        condition1_list.append(rg_condition)
        condition2_list.append(rg_condition)

    condition1 = " and ".join(condition1_list)
    condition2 = " and ".join(condition2_list)

    select = "select COLL_NAME, DATA_NAME, count(DATA_REPL_NUM)"

    select1 = select + " where " + condition1
    select2 = select + " where " + condition2

    ret = {}

    retcode, ret1 = iquest([select1])

    if retcode == 0:
        ret.update(ret1)

        if recursive:
            retcode, ret2 = iquest([select2])

            if retcode == 0:
                ret.update(ret2)

    return ret

def replicas_failed_filter(replicas, filterlist):
    "filter replica statuses that fail conditions"

    def aggregate_failed_filterlist(e):
        for f in filterlist:
            if not f(e[1]): return True

        return False

    failed = filter(aggregate_failed_filterlist, replicas.items())

    return failed

if __name__ == "__main__":
    import os.path

    from optparse import OptionParser

    usage="""\
usage: %prog [options] [--] <exact-replnum> | <minimum-replnum>+ | <maximum-replnum>- ...

checks wether files respect replica number conditions and prints files which fail the test.

There are 3 types of conditions
<exact-replnum> exact number of replicas 
<minimum-replnum>+ minimum number of replicas
<maximum-replnum>- maximum number of replicas

Examples:

# check files with 3 replicas or more
$ %prog 3+

# check files with exactly 2 replicas
$ %prog 2
"""

    parser = OptionParser(usage = usage)
    parser.add_option("-c", "--collection", dest="collection", default='.',
                      help="check files in COLL (default: .)", metavar="COLL")
    parser.add_option("-r", "--recursive",
                      action="store_true", dest="recursive", default=False,
                      help="Check files in subcollections")
    parser.add_option("-G", "--resource-group", dest="resource_group", default=None,
                      metavar="RESOURCE_GROUP",
                      help="Check replica numbers only for replicas in RESOURCE_GROUP")

    (options, args) = parser.parse_args()

    conditions = []

    for arg in args:
        if arg.endswith('+'):
            replnum = int (arg[:-1])
            conditions.append(lambda e: e >= replnum)
        elif arg.endswith('-'):
            replnum = int (arg[:-1])
            conditions.append(lambda e: e <= replnum)
        else:
            replnum = int (arg)
            conditions.append(lambda e: e == replnum)

    collection = options.collection

    if isrel(collection):
        icwd = guess_icwd()
        collection = os.path.normpath(icwd + '/' + collection)

    replicas = iquest_replicas(collection, user = guess_user(),
                               recursive = options.recursive)

    if options.resource_group:
        group_replicas = iquest_replicas(collection, user = guess_user(),
                                         recursive = options.recursive,
                                         resource_group = options.resource_group)

        # zero all files replica numbers
        for k in replicas: replicas[k] = 0

        # replace replica numbers by resource group replica numbers
        for k, v in group_replicas.iteritems(): replicas[k] = v

    failed = replicas_failed_filter(replicas, conditions)
    print failed

